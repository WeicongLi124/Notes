# **内存泄漏与内存溢出**
- Author：WeicongLee
- Data：2019.05.08

### **内存溢出 out of memory(OOM)：**
是指程序再申请内存时，没有足够的内存空间供其使用，出现OOM的错误；
### **内存泄漏 memory leak：**
是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，但内存泄漏堆积后果严重，无论多少内存，迟早会被占光。

## **一、以发生的方式来分类，内存泄漏分为四种：**
**1）常发性内存泄漏：** 发生内存泄漏的代码会被多次执行到，**每次被执行的时候都会导致一块内存泄漏**。

**2）偶发性内存泄漏：** 发生内存泄漏的代码**只有在某些特定环境或操作过程下才会发生**。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。

**3）一次性内存泄漏：** **发生内存泄漏的代码只会被执行一次**，或者由于算法上的缺陷，导致总会有一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。

**4）隐式内存泄漏：** 程序在运行过程中不停地分配内存，**直到结束的时候才释放内存**。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。我们称这类内存泄漏为隐式内存泄漏。

## **二、Java内存泄漏引起原因**
- 内存泄漏是指*无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放*，从而**造成的内存空间的浪费称为内存泄漏**。内存泄漏有时不严重且不易察觉，这样开发者就不知道存在内存泄漏，但有时也会很严重，提示out of memory(OOM)。
- **Java内存泄漏根本原因：** *长生命周期的对象持有短生命周期对象的引用*就很可能发生内存泄漏，尽管短生命周期对象已经不需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java内存泄漏的发生场景。

具体有如下几大类：

### **1）静态集合类引起内存泄漏：**

像HashMap、Vector等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，他们所引用的所有对象Object也不能被释放，因为他们也将一直被Vector等集合对象引用着。
```JAVA
static Vector v = new Vector(10);
for(itn i = 1; i < 100; i++){
    Object o = new Object();
    v.add(o);
    o = null;
}
```
在这个例子中，循环申请Object对象，并将所申请的对象放入一个Vector中，**如果仅仅释放引用本身（o=null），那么Vector仍然引用该对象，所以这个对象对GC来说是不可回收的。** 因此，如果对象加入到Vector后，还必须从Vector中删除，**最简单的方法就是将Vector对象设为null。**

### **2）监听器：**
在Java编程中，我们都需要跟监听器打交道，Android 中比较常见的是 Listener，Observer 等，一般被监听者的生命周期要比监听者的生命周期长，当监听者本身不被使用，但又没有移除被监听者对其的引用时就会造成内存无法释放，从而导致内存泄漏。

### **3）各种链接：**
- 如**数据库连接（dataSourse.getConnection()）、网络连接（Socket）和IO连接**，除非其显式的调用了close()方法将其连接关闭，否则是不会自动被GC回收的。
- 对于Resultset和Statement对象可以不进行显式回收，但Connection一定要显式回收，因为Connection在任何时候都无法自动回收，而Connection一旦回收，Resultset和Statement对象会立即为NULL
- 如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset和Statement对象（关闭其中一个，另一个也会关闭），否则就会造成大量的Statement对象无法释放，从而引起内存泄漏。**这种情况下一般都会在try里面去连接，在finally里面释放连接。**

### **4）单例模式：**
- 如果单例对象持有外部对象的引用，那么这个外部对象将不能被JVM正常回收，导致内存泄漏
- 不正确使用单例模式是引起内存泄漏的一个常见问题，**单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式）**，如果单例对象持有外部对象的引用，那么这个外部对象将不能被JVM正常回收，导致内存泄漏。

    如下例子：
    ```JAVA
    //被引用类
    public class A{
        public A(){
            B.getInstance().setA(this);
        }
    }
    //单例类
    public class B{
        private static B instance = new B();
        private A a;
        private B(){}

        public static B getInstance(){
            return instance;
        }
        public void setA(A a){
            this.a = a;
        }
    }
    ```
    B类采用了单例模式，它持有一个A对象，因为单例对象在被初始化后将在JVM的整个生命周期中存在，所以这个A类对象将不能被回收。